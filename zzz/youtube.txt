# -*- coding: utf-8 -*-
import datetime, multiprocessing, sys, os, random, re, json, subprocess, time, base64, tempfile, time, requests, threading, queue
from pathlib import Path
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from concurrent.futures import ThreadPoolExecutor
from PyQt6.QtWidgets import (QToolButton, QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QWidget,
                             QPushButton, QLineEdit, QComboBox, QLabel, QMessageBox, QFileDialog, QProgressBar,
                             QGroupBox, QGridLayout, QFrame, QScrollArea, QSpacerItem, QSizePolicy)

print(f"Python: {sys.executable}")

# ---------------------------------------------------------
MAX_THREADS = 4 
PREFERRED_BROWSER = "firefox"
BROWSERS = ['chrome', 'firefox', 'edge', 'brave']
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 '
    '(KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 '
    '(KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36',
]

PROXY_LIST = [
    'http://103.187.168.109:80',
    'http://103.153.154.209:80',
    'http://190.61.88.147:8080',
]

def build_safe_cmd(base_cmd, url, *, use_proxy=False, cookie_session=None, **kwargs):
    """
    Build yt-dlp command. 
    Ignores legacy kwargs like browser=... (no longer needed).
    """
    ua = random.choice(USER_AGENTS)
    cmd = list(base_cmd)

    netscape_path = None
    if cookie_session:
        netscape_path = _SESSION_MANAGER.cookie_netscape_path(cookie_session)
        if not os.path.exists(netscape_path) and _SESSION_MANAGER.has_cookie(cookie_session):
            cookies = _SESSION_MANAGER.load_cookies_json(cookie_session)
            _SESSION_MANAGER._write_netscape(cookies, netscape_path)

    if netscape_path and os.path.exists(netscape_path):
        cmd += ['--cookies', netscape_path]
    else:
        cmd += ['--no-cookies']

    cmd += ['--user-agent', ua, '--no-check-certificate']

    if use_proxy and PROXY_LIST:
        cmd += ['--proxy', random.choice(PROXY_LIST)]

    cmd += ['--', url]
    return cmd

def build_yt_dlp_cmd(base_cmd_list, url, cookie_session='default', use_proxy=False):
    """
    Wrapper around build_safe_cmd pro existující callsite, pokud někde voláš build_yt_dlp_cmd.
    base_cmd_list: list like ['yt-dlp', '--dump-json']
    """
    return build_safe_cmd(base_cmd_list, url, use_proxy=use_proxy, cookie_session=cookie_session)


def check_dependencies():
    """Zkontroluje, zda existují yt-dlp.exe, ffmpeg.exe a ffprobe.exe"""
    bin_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'bin')
    yt_dlp_path = os.path.join(bin_dir, "yt-dlp.exe") if sys.platform == "win32" else "yt-dlp"
    ffmpeg_path = os.path.join(bin_dir, "ffmpeg.exe") if sys.platform == "win32" else "ffmpeg"
    ffprobe_path = os.path.join(bin_dir, "ffprobe.exe") if sys.platform == "win32" else "ffprobe"
    try:
        creation_flags = subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0
    except Exception:
        creation_flags = 0
    try:
        subprocess.run([yt_dlp_path, '--version'], check=True, capture_output=True, creationflags=creation_flags)
    except (subprocess.CalledProcessError, FileNotFoundError):
        return "yt-dlp"
    try:
        subprocess.run([ffmpeg_path, '-version'], check=True, capture_output=True, creationflags=creation_flags)
    except (subprocess.CalledProcessError, FileNotFoundError):
        return "ffmpeg"
    try:
        subprocess.run([ffprobe_path, '-version'], check=True, capture_output=True, creationflags=creation_flags)
    except (subprocess.CalledProcessError, FileNotFoundError):
        return "ffprobe"
    return None

def check_gpu_support():
    bindir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "bin")
    ffmpeg_path = os.path.join(bindir, "ffmpeg.exe" if sys.platform == "win32" else "ffmpeg")
    try:
        creationflags = subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0
    except AttributeError:
        creationflags = 0
    gpu_candidates = [
        ("nvenc", ("h264_nvenc", "hevc_nvenc"), "NVIDIA"),
        ("amf", ("h264_amf", "hevc_amf"), "AMD"),
        ("qsv", ("h264_qsv", "hevc_qsv"), "Intel QuickSync"),
        ("vaapi", ("h264_vaapi", "hevc_vaapi"), "Linux VAAPI"),
        ("videotoolbox", ("h264_videotoolbox", "hevc_videotoolbox"), "macOS VideoToolbox"),
    ]
    try:
        res = subprocess.run(
            [ffmpeg_path, "-hide_banner", "-encoders"],
            capture_output=True, text=True, check=True, creationflags=creationflags, encoding='utf-8', errors='ignore'
        )
        encoders_out = res.stdout.lower()
    except Exception as e:
        print(f"Nepodařilo se spustit 'ffmpeg -encoders': {e}")
        return "cpu", "libx264"
    for mode, names, friendly_name in gpu_candidates:
        for name in names:
            if name in encoders_out:
                print(f"Nalezen potenciální enkodér: {name}. Provádím test funkčnosti...")
                test_cmd = [
                    ffmpeg_path, "-hide_banner", "-loglevel", "error",
                    "-f", "lavfi", "-i", "testsrc=size=192x108:rate=1",
                    "-t", "1", "-c:v", name, "-f", "null", "-"
                ]
                try:
                    test_proc = subprocess.run(
                        test_cmd, capture_output=True, text=True, creationflags=creationflags, timeout=8
                    )
                    if test_proc.returncode == 0:
                        print(f"ÚSPĚCH! Enkodér '{name}' je funkční. Používám {friendly_name}.")
                        return mode, name
                    else:
                        print(f"SELHÁNÍ. Enkodér '{name}' není funkční. Chyba: {test_proc.stderr.strip()}")
                except subprocess.TimeoutExpired:
                    print(f"SELHÁNÍ. Test enkodéru '{name}' vypršel (timeout).")
                except Exception as e:
                    print(f"SELHÁNÍ. Neočekávaná chyba při testu enkodéru '{name}': {e}")
                
                continue
    print("Nenalezen žádný funkční GPU enkodér. Používám CPU (libx264).")
    return "cpu", "libx264"

def get_unique_filepath(filepath):
    if not os.path.exists(filepath):
        return filepath
    path_obj = Path(filepath)
    directory = path_obj.parent
    filename = path_obj.stem
    extension = path_obj.suffix
    counter = 1
    while True:
        new_filename = f"{filename} ({counter}){extension}"
        new_filepath = directory / new_filename
        if not os.path.exists(new_filepath):
            return str(new_filepath)
        counter += 1

def get_original_bitrate(video_path):
    bin_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'bin')
    ffprobe_path = os.path.join(bin_dir, "ffprobe.exe") if sys.platform == "win32" else "ffprobe"
    try:
        cmd = [ffprobe_path, '-v', 'error', '-select_streams', 'v:0', '-show_entries', 'stream=bit_rate', '-of', 'default=noprint_wrappers=1:nokey=1', video_path]
        creation_flags = subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0
        result = subprocess.run(cmd, capture_output=True, text=True, check=True, encoding='utf-8', errors='replace', creationflags=creation_flags)
        bitrate_bps = int(result.stdout.strip())
        return round(bitrate_bps / 1000000, 1)
    except Exception:
        return 5.0

def calculate_bitrate(compression_preset, duration_s, original_bitrate):
    """Vypočítá bitrate podle upravených kompresních presetů."""
    compression_map = {
        "Original (No Re-encoding)": {"video_factor": 1.0, "audio_bitrate": 192},
        "High Quality (Compressed)": {"video_factor": 0.6, "audio_bitrate": 128},
        "Medium Quality": {"video_factor": 0.4, "audio_bitrate": 96},
        "Low Quality": {"video_factor": 0.25, "audio_bitrate": 64}
    }

    preset_settings = compression_map.get(compression_preset, compression_map["Original (No Re-encoding)"])
    v_factor = preset_settings["video_factor"]
    a_bitrate = preset_settings["audio_bitrate"]

    v_bitrate = original_bitrate * v_factor
    if duration_s > 600:
        length_factor = max(0.8, 1 - (duration_s - 600) / 7200.0)
        v_bitrate *= length_factor

    v_bitrate = max(0.5, round(v_bitrate, 1))
    return v_bitrate, a_bitrate

def canonicalize_youtube_url(url: str) -> str:
    if not url:
        return url
    url = url.strip()
    m = re.search(r'(?:v=|\/youtu\.be\/|\/embed\/)([A-Za-z0-9_-]{11})', url)
    if m:
        return f"https://www.youtube.com/watch?v={m.group(1)}"
    q = re.search(r'[?&]v=([A-Za-z0-9_-]{11})', url)
    if q:
        return f"https://www.youtube.com/watch?v={q.group(1)}"
    return url

class DownloadManager:
    def __init__(self):
        self.executor = ThreadPoolExecutor(max_workers=MAX_THREADS)
        self.ytdlppath = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'bin', 'yt-dlp.exe' if sys.platform == 'win32' else 'yt-dlp')
        self.active_downloads = {}

    def download(self, urls, params):
        futures = [self.executor.submit(self._download_single, url, params) for url in urls]
        for future in futures:
            future.add_done_callback(self._handle_download_done)

    def _download_single(self, url, params):
        try:
            session_name = params.get('cookie_session', 'default')
            cmd = build_safe_cmd([self.ytdlppath, '-f', 'best', '-o', params['output_path']], url)
            if params.get('playlist', False):
                cmd += ['--yes-playlist']
            subprocess.run(cmd, check=True)
            return True
        except Exception as e:
            try:
                cmd = [self.ytdlppath, '-f', 'best', '-o', params['output_path'], url]
                subprocess.run(cmd, check=True)
                return True
            except:
                raise RuntimeError(f"Download failed for {url}: {str(e)}")

    def _handle_download_done(self, future):
        try:
            result = future.result()
            print(f"Download complete: {result}")
        except Exception as e:
            print(f"Download error: {e}")

    def cancel(self):
        self._is_cancelled = True
        if self.process and self.process.poll() is None:
            try:
                self.process.terminate()
            except Exception:
                pass

def _extract_yt_initial_data_from_html(html):
    """
    Jednoduchý parser: najdi 'ytInitialData' v HTML a vrát JSON část.
    Vrátí None pokud nenajde.
    """
    import re
    m = re.search(r"var ytInitialData = (\{.*?\});", html, re.DOTALL)
    if not m:
        m = re.search(r"window\[['\"]ytInitialData['\"]\]\s*=\s*(\{.*?\});", html, re.DOTALL)
    if not m:
        m = re.search(r"ytInitialData\s*=\s*(\{.*?\});", html, re.DOTALL)
    if not m:
        return None
    txt = m.group(1)
    try:
        return json.loads(txt)
    except Exception:
        # někdy JSON obsahuje nedefinované tokeny; fallback - snažit se o opravy nebo vrátit None
        try:
            # naive cleanup (může pomoci)
            txt2 = txt.replace("undefined", "null")
            return json.loads(txt2)
        except Exception:
            return None

def _find_playlist_panel_videos(initial):
    # zjednodušeně: projít strukturu a najít video entries (tento helper přizpůsob podle původního parseru)
    videos = []
    def walk(node):
        if isinstance(node, dict):
            if node.get('videoId'):
                videos.append({'id': node.get('videoId'), 'title': node.get('title', {}).get('simpleText') if node.get('title') else None})
            for v in node.values():
                walk(v)
        elif isinstance(node, list):
            for i in node:
                walk(i)
    walk(initial)
    # deduplikační logika
    seen = set()
    out = []
    for v in videos:
        if v['id'] and v['id'] not in seen:
            seen.add(v['id'])
            out.append(v)
    return out

def _find_playlist_panel_title(initial):
    # pokus najít název playlist/panelu; jednoduchá heuristika
    def walk_for_title(node):
        if isinstance(node, dict):
            if 'title' in node and isinstance(node['title'], dict) and 'simpleText' in node['title']:
                return node['title']['simpleText']
            for v in node.values():
                t = walk_for_title(v)
                if t:
                    return t
        elif isinstance(node, list):
            for i in node:
                t = walk_for_title(i)
                if t:
                    return t
        return None
    return walk_for_title(initial)

def _scrape_radio_playlist(url, *, timeout=12):
    headers = {"User-Agent": random.choice(USER_AGENTS)}
    try:
        resp = requests.get(url, headers=headers, timeout=timeout)
    except Exception:
        resp = None

    initial = None
    if resp and resp.status_code == 200:
        initial = _extract_yt_initial_data_from_html(resp.text)

    if not initial:
        # fallback: try headless browser via SessionManager
        session_name = 'radio'
        try:
            _SESSION_MANAGER.create_session_from_url(url, name=session_name, headless=True, wait_ms=2500)
        except Exception:
            pass

        try:
            from playwright.sync_api import sync_playwright
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=True)
                context = browser.new_context()
                page = context.new_page()
                page.goto(url, wait_until='networkidle', timeout=15000)
                page.wait_for_timeout(2000)
                html = page.content()
                browser.close()
                initial = _extract_yt_initial_data_from_html(html)
        except Exception:
            initial = None

    if not initial:
        # poslední záchrana: yt-dlp flat-playlist
        try:
            cmd = build_safe_cmd(['yt-dlp', '--flat-playlist', '--dump-json'], url, cookie_session='radio')
            proc = subprocess.run(cmd, capture_output=True, text=True, timeout=20)
            lines = [l for l in proc.stdout.splitlines() if l.strip()]
            vids = []
            for ln in lines:
                try:
                    j = json.loads(ln)
                    if 'id' in j:
                        vids.append({'id': j['id'], 'title': j.get('title')})
                except Exception:
                    continue
            urls = [f"https://www.youtube.com/watch?v={v['id']}" for v in vids]
            title = f"Radio/Mix ({len(urls)} items)"
            entries = vids
            return {'title': title, 'urls': urls, 'entries': entries}
        except Exception:
            raise RuntimeError("ytInitialData not found and fallbacks failed")

    videos = _find_playlist_panel_videos(initial)
    title = _find_playlist_panel_title(initial) or f"Radio/Mix ({len(videos)} items)"
    urls = [f"https://www.youtube.com/watch?v={v['id']}" for v in videos]
    entries = [{'id': v['id'], 'title': v.get('title')} for v in videos]

    return {'title': title, 'urls': urls, 'entries': entries}

class SessionManager:
    """
    Robustní SessionManager — vytvoří bezpečně bin/ a základní cookie soubory při startu.
    Ukládá cookies do JSON (value base64) a zároveň vytváří kompatibilní Netscape TXT pro yt-dlp.
    Pokud Playwright není dostupný, vytvoří prázdné soubory jako bezpečný fallback.
    """

    def __init__(self, base_dir=None):
        # určení bin adresáře (pokud je zabaleno jako exe, použije se složka exe)
        if base_dir:
            self.base_dir = base_dir
        else:
            if getattr(sys, "frozen", False):
                prog_dir = os.path.dirname(sys.executable)
            else:
                prog_dir = os.path.dirname(os.path.abspath(__file__))
            self.base_dir = os.path.join(prog_dir, "bin")

        # vytvořit dir bezpečně
        try:
            os.makedirs(self.base_dir, exist_ok=True)
        except Exception:
            pass

        # zajisti existence defaultních souborů (bezpečné, atomické)
        try:
            default_json = self.cookie_json_path("default")
            default_txt = self.cookie_netscape_path("default")
            if not os.path.exists(default_json):
                fd, tmp = tempfile.mkstemp(prefix="cookies_", suffix=".json", dir=os.path.dirname(default_json))
                os.close(fd)
                try:
                    with open(tmp, "w", encoding="utf-8", newline="\n") as f:
                        json.dump([], f, ensure_ascii=False, indent=2)
                    os.replace(tmp, default_json)
                finally:
                    if os.path.exists(tmp):
                        try:
                            os.remove(tmp)
                        except Exception:
                            pass
            if not os.path.exists(default_txt):
                try:
                    with open(default_txt, "w", encoding="utf-8") as f:
                        f.write("# Netscape HTTP Cookie File\n")
                except Exception:
                    pass
        except Exception:
            pass

    def cookie_json_path(self, name="default"):
        return os.path.join(self.base_dir, f"cookies_{name}.json")

    def cookie_netscape_path(self, name="default"):
        return os.path.join(self.base_dir, f"cookies_{name}.txt")

    def has_cookie(self, name="default"):
        return os.path.exists(self.cookie_json_path(name))

    def save_cookies_json(self, cookies, name="default"):
        """
        Uloží cookies do JSON (base64 hodnoty) + vytvoří Netscape TXT.
        """
        safe_list = []
        for c in (cookies or []):
            raw_val = c.get("value") or ""
            value_b64 = base64.b64encode(raw_val.encode("utf-8")).decode("ascii")
            safe_list.append({
                "name": c.get("name") or "",
                "value_b64": value_b64,
                "domain": c.get("domain") or "",
                "path": c.get("path", "/"),
                "expires": int(c.get("expires", 0)) if c.get("expires") else 0,
                "secure": bool(c.get("secure", False)),
                "httpOnly": bool(c.get("httpOnly", False)),
            })

        json_path = self.cookie_json_path(name)
        txt_path = self.cookie_netscape_path(name)

        os.makedirs(os.path.dirname(json_path), exist_ok=True)

        with open(json_path, "w", encoding="utf-8") as f:
            json.dump(safe_list, f, ensure_ascii=False, indent=2)

        self._write_netscape(cookies, txt_path)
        return json_path

    def _write_netscape(self, cookies, netscape_path):
        """
        Zapíše cookies do Netscape formátu pro yt-dlp.
        """
        os.makedirs(os.path.dirname(netscape_path), exist_ok=True)
        with open(netscape_path, "w", encoding="utf-8") as f:
            f.write("# Netscape HTTP Cookie File\n")
            for c in (cookies or []):
                domain = c.get("domain", "")
                flag = "TRUE" if domain.startswith(".") else "FALSE"
                path = c.get("path", "/")
                secure = "TRUE" if c.get("secure", False) else "FALSE"
                expires = str(int(c.get("expires", 0))) if c.get("expires") else "0"
                name = c.get("name", "")
                value = c.get("value", "")
                f.write(f"{domain}\t{flag}\t{path}\t{secure}\t{expires}\t{name}\t{value}\n")

    def create_session_for_youtube(self, name="default", headless=True, interactive=False):
        """
        - headless=True → běží na pozadí, bez okna (pro start programu).
        - interactive=True → zobrazí prohlížeč, uživatel se přihlásí (např. přes tlačítko Login).
        """
        try:
            from playwright.sync_api import sync_playwright
            # Nezapomeň, že používáme starší verzi: playwright-stealth==1.0.6
            from playwright_stealth import stealth_sync
        except ImportError:
            print("[SessionManager] Playwright nebo Playwright-Stealth není dostupný.")
            print("Ujisti se, že máš nainstalováno: pip install playwright playwright-stealth==1.0.6")
            print("A také spuštěno: playwright install")
            return self.save_cookies_json([], name)

        profile_dir = os.path.join(self.base_dir, f"profile_{name}")
        os.makedirs(profile_dir, exist_ok=True)

        cookies_collected = []
        with sync_playwright() as p:
            chromium = p.chromium
            context = chromium.launch_persistent_context(
                user_data_dir=profile_dir,
                headless=headless,
                
                # --- Ultimátní sada maskovacích kouzel ---
                ignore_default_args=["--enable-automation"],
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36",
                
                args=[
                    "--disable-dev-shm-usage",
                    "--no-sandbox",
                    "--disable-blink-features=AutomationControlled",
                    "--disable-infobars",
                    "--no-first-run",
                    # Simulujeme, že máme normální grafické schopnosti
                    "--enable-webgl",
                    "--use-gl=swiftshader",
                    "--enable-accelerated-2d-canvas"
                ],
                # -------------------------------------------

                viewport={"width": 1280, "height": 800},
            )
            page = context.new_page()

            # Nasazení neviditelného pláště
            stealth_sync(page)

            print("[SessionManager] Otevírám YouTube...")

            try:
                # Dáme stránce trochu víc času na "nadechnutí"
                page.goto("https://www.youtube.com/", wait_until="domcontentloaded", timeout=30000)
            except Exception as e:
                print(f"[SessionManager] Chyba při načítání stránky: {e}")
                pass

                if interactive:
                    print("[SessionManager] Přihlašte se do YouTube. Po přihlášení stiskněte Enter v konzoli...")
                    input(">> Stiskněte Enter, až budete přihlášeni a stránka načtená.")
                else:
                    page.wait_for_timeout(5000)

            try:
                cookies = context.cookies()
                cookies_collected = [c for c in cookies if "youtube.com" in c["domain"] or "google.com" in c["domain"]]
            except Exception:
                cookies_collected = []

            context.close()

        return self.save_cookies_json(cookies_collected, name)


_SESSION_MANAGER = SessionManager()
# ----------------------
# MetadataManager - sekvenční yt-dlp requests + lokální cache + rychlé zpracování výsledků
# ----------------------
# Zkopíruj a nahraď celou původní třídu MetadataManager v souboru youtube.py

class MetadataManager(QThread):
    resolutions_fetched = pyqtSignal(str, object)  # url, data dict
    error = pyqtSignal(str, str)                   # url, message
    status_update = pyqtSignal(str, str)            # url, status text


    def __init__(self):
        super().__init__()
        self._queue = queue.Queue()
        self._stop_event = threading.Event()
        self.cache = {}  # url -> data dict
        self._current_url = None
        self._current_process = None
        self._cancelled = set()
        self._queue_lock = threading.Lock()
        self.executor = ThreadPoolExecutor(max_workers=MAX_THREADS)
        bin_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'bin')
        self.yt_dlp_path = os.path.join(bin_dir, "yt-dlp.exe") if sys.platform == "win32" else "yt-dlp"
        try:
            self.creation_flags = subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0
        except Exception:
            self.creation_flags = 0
        self.start()


    def run(self):
        while not self._stop_event.is_set():
            try:
                item = self._queue.get(timeout=0.2)
            except queue.Empty:
                continue
            if item is None:
                break


            if item in self._cancelled:
                self._cancelled.discard(item)
                continue


            url = item
            if url in self.cache:
                self.resolutions_fetched.emit(url, self.cache[url])
                continue


            future = self.executor.submit(self._fetch_metadata, url)
            future.add_done_callback(lambda f, u=url: self._handle_fetch_done(f, u))


    def request(self, urls):
        if isinstance(urls, str):
            urls = [urls]
        for url in urls:
            if not url:
                continue
            if "list=RD" in url or "start_radio=1" in url:
                norm = url.strip()
            else:
                norm = canonicalize_youtube_url(url)


            if norm in self.cache:
                try:
                    self.resolutions_fetched.emit(norm, self.cache[norm])
                except Exception:
                    pass
                continue


            with self._queue_lock:
                self._queue.put(norm)


def detect_tracklist(video_json):
    """
    Najde a vrátí tracklist ve formě seznamu slovníků:
    [{'title': ..., 'start_time': ...}, ...]
    1. Nejprve zkusí chapters v metadatech.
    2. Pokud nejsou, zkusí najít tracklist v popisu videa (description).
    """
    chapters = video_json.get("chapters", [])
    if chapters:
        print(f"Tracklist detekován v metadatech! Počet skladeb: {len(chapters)}")
        for idx, ch in enumerate(chapters, 1):
            print(f"{idx}. {ch.get('title','Unknown')} ({ch.get('start_time',0)}s)")
        return chapters

    # Fallback: Parsování tracklistu z popisu videa
    import re
    description = video_json.get("description", "")
    pattern = r"^(\d{1,2}:\d{2})\s+(.+)$"
    tracklist = []
    for line in description.splitlines():
        m = re.match(pattern, line.strip())
        if m:
            time_str, title = m.groups()
            parts = [int(x) for x in time_str.split(":")]
            if len(parts) == 2:
                minutes, seconds = parts
                start_time = minutes * 60 + seconds
            else:
                start_time = 0
            tracklist.append({"title": title.strip(), "start_time": start_time})
    if tracklist:
        print(f"Tracklist detekován v popisu! Počet skladeb: {len(tracklist)}")
        for idx, ch in enumerate(tracklist, 1):
            print(f"{idx}. {ch['title']} ({ch['start_time']}s)")
        return tracklist
    print("Tracklist nenalezen.")
    return []

class MetadataManager(QThread):
    # ... zbytek třídy beze změny ...

    def _fetch_metadata(self, url):
        # --- radio / mix speciální případ (ponecháno beze změny) ---
        if "list=RD" in url or "start_radio=1" in url:
            self.status_update.emit(url, " Loading playlist info...")
            try:
                try:
                    scraped = _scrape_radio_playlist(url)
                except Exception as scrap_e:
                    scraped = None
                    print(f"Radio scrape failed: {scrap_e}")

                if scraped and scraped.get("urls"):
                    data = {
                        "is_playlist": True,
                        "is_radio_playlist": True,
                        "entries": scraped.get("entries", []),
                        "urls": scraped.get("urls", []),
                        "title": scraped.get("title", f"Radio/Mix playlist ({len(scraped.get('urls', []))} items)")
                    }
                    self.cache[url] = data
                    return data

                # 2) fallback na yt-dlp --flat-playlist
                cmd = [self.yt_dlp_path, "--flat-playlist", "--dump-json", url]
                process = subprocess.Popen(
                    cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    encoding="utf-8",
                    errors="replace",
                    creationflags=self.creation_flags
                )
                stdout, stderr = process.communicate(timeout=60)
                if not stdout.strip():
                    raise RuntimeError(f"No playlist data (stderr: {stderr})")

                items = [json.loads(line) for line in stdout.splitlines() if line.strip()]
                video_urls = [f"https://www.youtube.com/watch?v={it['id']}" for it in items if "id" in it]
                data = {
                    "is_playlist": True,
                    "entries": items,
                    "urls": video_urls,
                    "title": f"Radio/Mix playlist ({len(video_urls)} items)"
                }
                self.cache[url] = data
                return data
            except Exception as e:
                raise RuntimeError(f"Playlist metadata fetch failed: {str(e)}")

        # --- FINÁLNĚ OPRAVENÁ LOGIKA PRO VIDEA ---
        self.status_update.emit(url, " Loading video info...")

        strategies = [
            ("web_safari", False, "Safari Klient"),  # Nejspolehlivější, primární volba
            ("default", True, "Výchozí (s cookies)"),  # Fallback, pokud Safari selže
            ("tv", False, "TV Klient (proti banu)"),  # Další fallback
            ("default", False, "Výchozí (bez cookies)"),  # Poslední možnost
        ]

        last_error_message = "Unknown error"

        for client, use_browser_cookies, log_name in strategies:
            self.status_update.emit(url, f"Zkouším identitu: {log_name}...")
            try:
                cmd = [self.yt_dlp_path, "--dump-json", "--no-playlist", "--user-agent", random.choice(USER_AGENTS)]

                if client != "default":
                    cmd.extend(["--extractor-args", f"youtube:player_client={client}"])

                if use_browser_cookies:
                    for browser in BROWSERS:
                        cmd.extend(["--cookies-from-browser", browser])
                else:
                    cmd.append("--no-cookies")

                cmd.append(url)

                print(f"[MetadataManager] Spouštím: {' '.join(cmd)}")

                process = subprocess.Popen(
                    cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                    text=True, encoding='utf-8', errors='replace',
                    creationflags=self.creation_flags
                )
                stdout, stderr = process.communicate(timeout=60)

                if process.returncode != 0 or not stdout.strip():
                    raise RuntimeError(stderr or "yt-dlp nevrátil žádná data.")

                video_info = json.loads(stdout)

                # === TADY JE DETEKCE TRACKLISTU ===
                tracklist = detect_tracklist(video_info)
                if tracklist:
                    print("Tracklist detekován a split je možný!")
                    print(f"Počet skladeb: {len(tracklist)}")
                    for i, ch in enumerate(tracklist, 1):
                        print(f"{i}. {ch['title']} (od {ch['start_time']}s)")
                    # Tady můžeš přidat dialog/volbu splitu uživateli

                formats = video_info.get("formats", [])
                resolutions = sorted(
                    list({f"{f['height']}p" for f in formats if f.get("vcodec") != "none" and f.get("height")}),
                    key=lambda r: int(r[:-1]) if r[:-1].isdigit() else 0,
                    reverse=True
                )
                if not resolutions:
                    raise RuntimeError("Nebyly nalezeny žádné video formáty, pouze audio nebo obrázky.")

                data = {
                    "resolutions": resolutions,
                    "duration": video_info.get("duration", 0),
                    "title": video_info.get("title", "Unknown Title")
                }
                self.cache[url] = data
                return data

            except Exception as e:
                last_error_message = str(e)
                print(f"[MetadataManager] Pokus s '{log_name}' selhal: {str(e)[:300]}...")
                low_err = last_error_message.lower()

                # *** Seznam všech "měkkých" chyb, které dovolí pokračovat ***
                skippable_errors = [
                    "nsig", "sabr", "format is not available", "missing a url",
                    "could not find", "cookies database", "permission denied",
                    "failed to decrypt", "dpapi"
                ]

                if any(key in low_err for key in skippable_errors):
                    continue # Je to očekávaná chyba, zkusíme další metodu
                else:
                    break # Jiná, neočekávaná chyba, nemá smysl zkoušet dál

        raise RuntimeError(f"Načtení metadat selhalo po všech pokusech.\n\nPoslední chyba:\n{last_error_message}")

    # === DOPORUČENÁ NOVÁ FUNKCE na detekci tracklistu ===
    def detect_tracklist(video_json):
        """
        Najde a vrátí tracklist ve formě seznamu slovníků:
        [{'title': ..., 'start_time': ...}, ...]
        1. Nejprve zkusí chapters v metadatech.
        2. Pokud nejsou, zkusí najít tracklist v popisu videa (description).
        """
        # 1. Kapitoly z metadat
        chapters = video_json.get("chapters", [])
        if chapters:
            print(f"Tracklist detekován v metadatech! Počet skladeb: {len(chapters)}")
            for idx, ch in enumerate(chapters, 1):
                print(f"{idx}. {ch.get('title','Unknown')} ({ch.get('start_time',0)}s)")
            return chapters

        # 2. Fallback: Parsování tracklistu z popisu videa
        description = video_json.get("description", "")
        pattern = r"^(\d{1,2}:\d{2})\s+(.+)$"
        tracklist = []
        for line in description.splitlines():
            m = re.match(pattern, line.strip())
            if m:
                time_str, title = m.groups()
                # Přepočet času na sekundy:
                parts = [int(x) for x in time_str.split(":")]
                if len(parts) == 2:
                    minutes, seconds = parts
                    start_time = minutes * 60 + seconds
                else:
                    start_time = 0
                tracklist.append({"title": title.strip(), "start_time": start_time})
        if tracklist:
            print(f"Tracklist detekován v popisu! Počet skladeb: {len(tracklist)}")
            for idx, ch in enumerate(tracklist, 1):
                print(f"{idx}. {ch['title']} ({ch['start_time']}s)")
            return tracklist
        # Pokud nenalezeno nic:
        print("Tracklist nenalezen.")
        return []


    def _handle_fetch_done(self, future, url):
        try:
            data = future.result()
            self.status_update.emit(url, "Ready...")
            self.resolutions_fetched.emit(url, data)
        except Exception as e:
            self.error.emit(url, str(e))
        finally:
            self._current_url = None
            self._current_process = None


    def cancel(self, url):
        if not url:
            return
        norm = url.strip()
        self._cancelled.add(norm)
        if self._current_url == norm and self._current_process:
            try:
                self._current_process.terminate()
            except Exception:
                pass
            self._current_url = None
            self._current_process = None
        try:
            with self._queue_lock:
                new_q = queue.Queue()
                while True:
                    try:
                        item = self._queue.get_nowait()
                        if item != norm:
                            new_q.put(item)
                    except queue.Empty:
                        break
            self._queue = new_q
        except Exception:
            pass
        self.cache.pop(norm, None)

# ----------------------
# InfoFetchThread (reused)
# ----------------------

class InfoFetchThread(threading.Thread):  # pokud používáš QThread, přepiš podle signálů
    def __init__(self, url, yt_dlp_path='yt-dlp', status_update=None, resolutions_fetched=None, error=None):
        super().__init__()
        self.url = url
        self.yt_dlp_path = yt_dlp_path
        # status_update, resolutions_fetched, error mohou být callable / signály; přizpůsob
        self.status_update = status_update or (lambda *a, **k: None)
        self.resolutions_fetched = resolutions_fetched or (lambda *a, **k: None)
        self.error = error or (lambda *a, **k: None)

    def run(self):
        try:
            self.status_update("Loading video info...")
            session_name = 'default'
            # ensure internal cookie session exists (headless create if missing)
            if not _SESSION_MANAGER.has_cookie(session_name):
                try:
                    _SESSION_MANAGER.create_session_from_url(self.url, name=session_name, headless=True, wait_ms=3000)
                except Exception:
                    # ignore — fallback bude bez cookies
                    pass

            # build safe command (prefer internal netscape cookie file)
            cmd = build_safe_cmd([self.yt_dlp_path, '--dump-json'], self.url, cookie_session=session_name)
            creation_flags = subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0

            # run command
            proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = proc.communicate(timeout=30)
            try:
                out_text = stdout.decode('utf-8')
            except Exception:
                try:
                    out_text = stdout.decode('cp1250', errors='replace')
                except Exception:
                    out_text = stdout.decode('utf-8', errors='replace')

            if not out_text.strip():
                # maybe error — include stderr in exception
                try:
                    err_text = stderr.decode('utf-8', errors='replace')
                except Exception:
                    err_text = str(stderr)
                raise RuntimeError(f"yt-dlp returned no output. stderr: {err_text}")

            video_info = json.loads(out_text)
            formats = video_info.get('formats', [])
            resolutions = sorted(list({f.get('height') for f in formats if f.get('vcodec') != 'none' and f.get('height')}), reverse=True)
            resolutions_str = [f"{r}p" for r in resolutions if isinstance(r, int)]

            if resolutions_str:
                self.status_update("Ready to download...")
                self.resolutions_fetched({
                    "resolutions": resolutions_str,
                    "duration": video_info.get('duration', 0),
                    "title": video_info.get('title', 'Unknown Title')
                })
            else:
                self.error("No video streams found.")
        except subprocess.TimeoutExpired:
            self.error("yt-dlp timed out while fetching metadata.")
        except Exception as e:
            self.error(f"Failed to get video info: {str(e)}")


# ----------------------
# DownloadThread (reused)
# ----------------------
# Zkopíruj a nahraď celou stávající třídu DownloadThread v youtube.py

class DownloadThread(QThread):
    progress = pyqtSignal(int, str)
    finished = pyqtSignal(bool)
    error = pyqtSignal(str)

    def __init__(self, **kwargs):
        super().__init__()
        self.params = kwargs
        self._is_cancelled = False
        self.process = None
        bin_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'bin')
        self.yt_dlp_path = os.path.join(bin_dir, "yt-dlp.exe") if sys.platform == "win32" else "yt-dlp"
        self.ffmpeg_path = os.path.join(bin_dir, "ffmpeg.exe") if sys.platform == "win32" else "ffmpeg"
        try:
            self.gpu_mode, self.gpu_encoder = check_gpu_support()
        except Exception:
            self.gpu_mode, self.gpu_encoder = ("cpu", "libx264")
        self._last_emitted_percent = -1

    def cancel(self):
        self._is_cancelled = True
        if self.process and self.process.poll() is None:
            self.progress.emit(5000, "Cancelling...")
            try:
                self.process.terminate()
            except Exception:
                pass

    def run(self):
        urls = self.params.get('urls', [])
        for idx, url in enumerate(urls):
            if self._is_cancelled:
                break
            try:
                title_safe = self.params.get('title') or f"video_{idx+1}"
                title_safe = re.sub(r'[\\/*?:"<>|]', "", title_safe)
                if self.params.get('format_opt') == 'MP3':
                    self._download_mp3(url, title_safe)
                else:
                    self._download_mp4(url, title_safe)
                if not self._is_cancelled:
                    self.progress.emit(100, "Downloading... 100%")
            except InterruptedError:
                self.error.emit("Cancelled")
                break
            except Exception as e:
                self.error.emit(str(e))
                break
        if not self._is_cancelled:
            self.finished.emit(True)

    def _download_mp3(self, url, title_safe):
        mp3_path = get_unique_filepath(os.path.join(self.params['save_path'], f"{title_safe}.mp3"))
        cmd = [
            self.yt_dlp_path, '--progress',
            '--extract-audio', '--audio-format', 'mp3',
            '-o', mp3_path,
            '--ffmpeg-location', self.ffmpeg_path,
            '--audio-quality', f"{self.params.get('mp3_bitrate', 320)}K",
            url
        ]
        self._run_process(cmd, phase_start=0, phase_end=100)

    def _download_mp4(self, url, titlesafe):
        final_path = get_unique_filepath(os.path.join(self.params["save_path"], f"{titlesafe}.mp4"))

        quality_str = self.params.get('video_quality', '1080p')
        m = re.search(r"(\d+)", quality_str or "")
        quality_height = m.group(1) if m else "1080"

        format_selector = (
            f"bestvideo[height<={quality_height}][vcodec^=av01]+bestaudio/"
            f"bestvideo[height<={quality_height}][vcodec^=vp9]+bestaudio/"
            f"bestvideo[height<={quality_height}][ext=mp4]+bestaudio/"
            f"bestvideo[height<={quality_height}]+bestaudio/"
            f"best"
        )
        
        base_cmd = [
            self.yt_dlp_path, '--progress',
            '--retries', '10',
            '--fragment-retries', '20',
            '--retry-sleep', 'fragment:2',  # OPRAVENO: 'fragment' (jednotné číslo)
            '--concurrent-fragments', '8',
            '--ffmpeg-location', self.ffmpeg_path,
            '-o', final_path
        ]
        
        base_cmd.extend(['-f', format_selector])
        base_cmd.append(url)

        strategies = [
            ("web_safari", False, "Safari Klient"),  # Primární volba
            ("default", True, "Výchozí (s cookies)"),  # Fallback, pokud Safari selže
            ("tv", False, "TV Klient (proti banu)"),  # Další fallback
            ("default", False, "Výchozí (bez cookies)"),  # Poslední možnost
        ]

        last_error_message = "Unknown download error"

        # Primární pokus s web_safari
        primary_client = strategies[0]  # web_safari
        fallback_clients = strategies[1:]  # Ostatní klienti

        # Nejprve zkusíme primární klienta (web_safari)
        try:
            client, use_browser_cookies, log_name = primary_client
            print(f"[DownloadThread] Zkouším stahovat s primární identitou: {log_name}...")
            cmd = list(base_cmd)
            if client != "default":
                cmd.extend(["--extractor-args", f"youtube:player_client={client}"])
            if use_browser_cookies:
                for browser in BROWSERS:
                    cmd.extend(["--cookies-from-browser", browser])
            else:
                cmd.append("--no-cookies")

            self._run_process(cmd, phase_start=0, phase_end=100)
            return  # Pokud primární klient uspěje, ukončíme funkci
        except Exception as e:
            last_error_message = str(e)
            print(f"[DownloadThread] Primární pokus s '{log_name}' selhal: {str(e)[:250]}...")

        # Pokud primární klient selže, zkusíme fallback klienty
        for client, use_browser_cookies, log_name in fallback_clients:
            try:
                print(f"[DownloadThread] Zkouším stahovat s fallback identitou: {log_name}...")
                cmd = list(base_cmd)
                if client != "default":
                    cmd.extend(["--extractor-args", f"youtube:player_client={client}"])
                if use_browser_cookies:
                    for browser in BROWSERS:
                        cmd.extend(["--cookies-from-browser", browser])
                else:
                    cmd.append("--no-cookies")

                self._run_process(cmd, phase_start=0, phase_end=100)
                return  # Pokud fallback klient uspěje, ukončíme funkci
            except Exception as e:
                last_error_message = str(e)
                print(f"[DownloadThread] Pokus s '{log_name}' selhal: {str(e)[:250]}...")
                low_err = last_error_message.lower()

                skippable_errors = [
                    "nsig", "sabr", "format is not available", "missing a url",
                    "could not find", "cookies database", "permission denied",
                    "failed to decrypt", "dpapi", "invalid http retry"
                ]

                if any(key in low_err for key in skippable_errors):
                    continue  # Přeskočíme na dalšího klienta
                else:
                    raise

        # Pokud všechny pokusy selžou, vyvoláme chybu
        raise RuntimeError(f"Stahování selhalo po všech pokusech.\n\nPoslední chyba:\n{last_error_message}")

    def _run_process(self, cmd, phase_start=0, phase_end=100):
        try:
            creation_flags = subprocess.CREATE_NO_WINDOW if sys.platform == "win32" else 0
        except Exception:
            creation_flags = 0

        stderr_buffer = []
        self.process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding="utf-8",
            errors="replace",
            bufsize=1,
            creationflags=creation_flags
        )
        
        def read_stderr():
            for line in self.process.stderr:
                stderr_buffer.append(line)

        stderr_thread = threading.Thread(target=read_stderr)
        stderr_thread.start()
        
        last_emitted = self._last_emitted_percent

        for raw_line in self.process.stdout:
            if self._is_cancelled:
                try:
                    self.process.terminate()
                except Exception:
                    pass
                raise InterruptedError()

            line = raw_line.strip()
            m = re.search(r'\[download\]\s*([\d\.]+)\%', line)
            if m:
                try:
                    percent = float(m.group(1))
                    mapped = phase_start + (percent / 100.0) * (phase_end - phase_start)
                    mapped_int = int(min(max(round(mapped), 0), 100))
                    if mapped_int > last_emitted:
                        last_emitted = mapped_int
                        self._last_emitted_percent = mapped_int
                        self.progress.emit(mapped_int, f"Downloading... {mapped_int}%")
                except Exception:
                    pass
        
        self.process.wait()
        stderr_thread.join()
        
        if self.process.returncode != 0 and not self._is_cancelled:
            error_output = "".join(stderr_buffer).strip()
            raise RuntimeError(error_output or "Download failed with unknown error")

        if last_emitted < 100:
            self.progress.emit(100, "Downloading... 100%")
            self._last_emitted_percent = 100

    def detect_adaptive_streams(self, formats):
        """
        Detect if the video has adaptive streams (separate video and audio).
        Returns two booleans: has_video, has_audio.
        """
        has_video = any(f.get("vcodec") != "none" for f in formats)
        has_audio = any(f.get("acodec") != "none" for f in formats)
        return has_video, has_audio

    def ask_split_video(self, has_video, has_audio):
        """
        Ask the user if they want to split video and audio downloads.
        Returns True if the user chooses to split, False otherwise.
        """
        if has_video and has_audio:
            reply = QMessageBox.question(
                self, "Split Video and Audio?",
                "Adaptive streams detected (separate video and audio). "
                "Do you want to download only video or audio separately?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            return reply == QMessageBox.Yes
        return False

    def download_video(self, url):
        """
        Download video with the option to split video and audio streams.
        """
        # Fetch metadata
        data = self.fetch_metadata(url)
        formats = data.get("formats", [])
        has_video, has_audio = self.detect_adaptive_streams(formats)

        # Ask the user if they want to split video and audio
        split = self.ask_split_video(has_video, has_audio)

        # Base command for yt-dlp
        base_cmd = [
            self.yt_dlp_path, '--progress',
            '--retries', '10',
            '--fragment-retries', '20',
            '--retry-sleep', 'fragment:2',
            '--concurrent-fragments', '8',
            '--ffmpeg-location', self.ffmpeg_path,
            '-o', self.get_output_path(url)
        ]

        # Modify the command based on the user's choice
        if split:
            if has_video:
                base_cmd.extend(["-f", "bestvideo"])
            elif has_audio:
                base_cmd.extend(["-f", "bestaudio"])
        else:
            base_cmd.extend(["-f", "bestvideo+bestaudio"])

        # Download using the primary client (web_safari) and fallback clients
        strategies = [
            ("web_safari", False, "Safari Client"),  # Primary choice
            ("default", True, "Default (with cookies)"),  # Fallback
            ("tv", False, "TV Client (anti-ban)"),  # Fallback
            ("default", False, "Default (no cookies)")  # Last resort
        ]

        last_error_message = "Unknown download error"

        # Try the primary client first
        primary_client = strategies[0]
        fallback_clients = strategies[1:]

        try:
            client, use_browser_cookies, log_name = primary_client
            print(f"[DownloadThread] Trying to download with primary client: {log_name}...")
            cmd = list(base_cmd)
            if client != "default":
                cmd.extend(["--extractor-args", f"youtube:player_client={client}"])
            if use_browser_cookies:
                for browser in BROWSERS:
                    cmd.extend(["--cookies-from-browser", browser])
            else:
                cmd.append("--no-cookies")

            self._run_process(cmd, phase_start=0, phase_end=100)
            return  # Exit if the primary client succeeds
        except Exception as e:
            last_error_message = str(e)
            print(f"[DownloadThread] Primary attempt with '{log_name}' failed: {str(e)[:250]}...")

        # Try fallback clients if the primary client fails
        for client, use_browser_cookies, log_name in fallback_clients:
            try:
                print(f"[DownloadThread] Trying to download with fallback client: {log_name}...")
                cmd = list(base_cmd)
                if client != "default":
                    cmd.extend(["--extractor-args", f"youtube:player_client={client}"])
                if use_browser_cookies:
                    for browser in BROWSERS:
                        cmd.extend(["--cookies-from-browser", browser])
                else:
                    cmd.append("--no-cookies")

                self._run_process(cmd, phase_start=0, phase_end=100)
                return  # Exit if a fallback client succeeds
            except Exception as e:
                last_error_message = str(e)
                print(f"[DownloadThread] Attempt with '{log_name}' failed: {str(e)[:250]}...")
                continue

        # Raise an error if all attempts fail
        raise RuntimeError(f"Download failed after all attempts.\n\nLast error:\n{last_error_message}")

class URLLineWidget(QWidget):
    line_edited = pyqtSignal()
    delete_requested = pyqtSignal(object)
    paste_multi = pyqtSignal(object, list)
    
    def __init__(self, parent_dialog=None, initial_url='', is_first=False):
        super().__init__()
        self.parent_dialog = parent_dialog
        self.is_first = is_first
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
        
        top_row = QHBoxLayout()
        top_row.setSpacing(6)
        
        # Pole pro URL
        self.line_edit = QLineEdit(initial_url, placeholderText="Enter URL...")
        self.line_edit.setClearButtonEnabled(True)
        
        # Tlačítko Paste
        self.btn_paste = QPushButton("Paste")
        self.btn_paste.setFixedSize(60, 28)
        
        # Tlačítko ❌ - vždy vytvoříme
        self.btn_remove = QToolButton(self)
        self.btn_remove.setText("❌")
        self.btn_remove.setFixedSize(28, 28)
        self.btn_remove.setToolTip("Remove this row")
        self.btn_remove.setStyleSheet("""
        QToolButton {
            background: transparent;
            color: red;
            font-size: 16px;
            border: none;
        }
        QToolButton:hover { color: #ff5555; }
        """)
        self.btn_remove.clicked.connect(lambda: self.delete_requested.emit(self))

        # Spacer 
        self.spacer_item = QSpacerItem(35, 28, QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
        self._has_spacer = False

        top_row.addWidget(self.line_edit)
        top_row.addWidget(self.btn_paste)
        top_row.addWidget(self.btn_remove)

        layout.addLayout(top_row)
        self._top_row = top_row

        # Meta label
        self.meta_label = QLabel("")
        self.meta_label.setWordWrap(True)
        self.meta_label.setStyleSheet("color: #666; font-size: 11px;")
        layout.addWidget(self.meta_label)
        
        # Connections
        self.line_edit.textChanged.connect(self.on_text_changed)
        self.line_edit.returnPressed.connect(self.on_return_pressed)
        self.btn_paste.clicked.connect(self._handle_paste)
        self.line_edit.keyPressEvent = self._key_press_event_custom
        if self.is_first:
            self.line_edit.textChanged.connect(self._on_first_line_changed)
        self.btn_paste.setStyleSheet("""QPushButton { background-color: #2a82da; color: white; font-weight: bold; padding: 4px 10px; border-radius: 6px;}QPushButton:hover { background-color: #3d95ed; } QPushButton:pressed { background-color: #1e6bb8; }""")

    def _on_first_line_changed(self, text):
        if not text and self.parent_dialog and hasattr(self.parent_dialog, 'check_and_remove_empty_line_if_only_first'):
            self.parent_dialog.check_and_remove_empty_line_if_only_first()
    
    def _key_press_event_custom(self, event):
        if event.key() == Qt.Key.Key_Delete and event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            self.line_edit.selectAll()
            self.line_edit.clear()
        else:
            QLineEdit.keyPressEvent(self.line_edit, event)
    
    def _handle_paste(self):
        clip = QApplication.clipboard().text().strip()
        if not clip:
            return

        parts = [p.strip() for p in re.split(r'[\r\n]+', clip) if p.strip()]
        url_pattern = re.compile(r'^https?://(?:www\.)?(youtube\.com|youtu\.be)/\S+')
        urls = [p for p in parts if url_pattern.match(p)]
        if not urls:
            QMessageBox.information(self, "Invalid URL", "Clipboard does not contain a valid YouTube URL.")
            return
        if "list=RD" in urls[0] or "start_radio=1" in urls[0]:
            first_canon = urls[0]
        else:
            first_canon = canonicalize_youtube_url(urls[0])
        self.line_edit.setText(first_canon)
        if len(urls) > 1:
            remaining = [
                u if ("list=RD" in u or "start_radio=1" in u) else canonicalize_youtube_url(u)
                for u in urls[1:]
            ]
            self.paste_multi.emit(self, remaining)

    def on_text_changed(self, text):
        old_url = getattr(self, "_last_url", "").strip()
        self.line_edited.emit()

        if not text.strip():
            self.clear_meta()
            if old_url:
                parent = self.parent()
                while parent and not hasattr(parent, 'metadata_manager') and not hasattr(parent, '_mgr_callbacks'):
                    parent = parent.parent()
                mgr = getattr(parent, 'metadata_manager', None)
                if mgr:
                    try:
                        mgr.cancel(old_url)
                    except Exception:
                        pass
                if hasattr(parent, '_loading_timers') and self in parent._loading_timers:
                    try: parent._loading_timers[self].stop()
                    except Exception: pass
                    parent._loading_timers.pop(self, None)

                if hasattr(parent, '_mgr_callbacks') and self in parent._mgr_callbacks:
                    try:
                        mgr, on_fetched, on_error, on_status, _ = parent._mgr_callbacks[self]
                        try: mgr.resolutions_fetched.disconnect(on_fetched)
                        except Exception: pass
                        try: mgr.error.disconnect(on_error)
                        except Exception: pass
                        try: mgr.status_update.disconnect(on_status)
                        except Exception: pass
                    except Exception:
                        pass
                    parent._mgr_callbacks.pop(self, None)
        self._last_url = text

    def on_return_pressed(self):
        self.line_edited.emit()
    
    def get_url(self):
        return self.line_edit.text().strip()
    
    def set_meta(self, text):
        try:
            self.meta_label.setText(text)
        except RuntimeError:
            pass
    
    def clear_meta(self):
        self.meta_label.setText("")
    
    def is_empty(self):
        return self.get_url() == ""
    
    def _on_text_changed(self, text):
        text = text.strip()
        if re.match(r'^https?://(www\.)?(youtube\.com|youtu\.be)/\S+', text):
            if "list=RD" in text or "start_radio=1" in text:
                norm = text
            else:
                norm = canonicalize_youtube_url(text)

            parent = self.parent()
            while parent and not hasattr(parent, 'fetch_meta_for_widget'):
                parent = parent.parent()
            if parent and hasattr(parent, 'fetch_meta_for_widget'):
                self.line_edit.blockSignals(True)
                self.line_edit.setText(norm)
                self.line_edit.blockSignals(False)
                parent.fetch_meta_for_widget(self)


class MultiURLDialog(QFrame):
    closed = pyqtSignal(list)

    def __init__(self, parent=None, urls=None):
        super().__init__(parent, Qt.WindowType.Dialog)
        self._owner = parent
        self.setWindowTitle("Enter Multiple URLs")
        self.setFixedSize(560, 420)
        self.layout = QVBoxLayout(self)
        self.layout.setSpacing(12)
        self.layout.setContentsMargins(12, 12, 12, 12)
        self.line_widgets = []
        self.info_threads = {}
        self._mgr_callbacks = {}
        self.scroll_area = QScrollArea(widgetResizable=True)
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setSpacing(8)
        self.scroll_layout.addStretch()
        self.scroll_area.setWidget(self.scroll_content)
        self.layout.addWidget(self.scroll_area)
        instructions = QLabel("Paste multiple URLs (each on a new line) or add them one by one. Metadata will be loaded per URL.")
        instructions.setStyleSheet("color: #999; font-size: 11px;")
        self.layout.addWidget(instructions)

        # Připravíme URL pro zobrazení
        initial_first_url = ""
        remaining_urls = []
        if urls:
            initial_first_url = urls[0]
            remaining_urls = urls[1:]

        # Vytvoříme první řádek, rovnou s URL, pokud existuje
        first = URLLineWidget(parent_dialog=self, initial_url=initial_first_url, is_first=True)
        first.line_edited.connect(lambda w=first: self.on_line_edited(w))
        first.delete_requested.connect(self.delete_line)
        first.paste_multi.connect(self.handle_paste_multi)
        self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, first)
        self.line_widgets.append(first)
        self.first_line = first
        if self.first_line.get_url():
            self.fetch_meta_for_widget(self.first_line)
        if remaining_urls:
            for u in remaining_urls:
                self.add_line(u)
        self.ensure_trailing_empty()
        self.update_remove_buttons()

        # Tlačítka OK a Cancel
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        btn_ok = QPushButton("OK")
        btn_cancel = QPushButton("Cancel")
        btn_ok.clicked.connect(self.accept)
        btn_cancel.clicked.connect(self.reject)
        btn_layout.addWidget(btn_ok)
        btn_layout.addWidget(btn_cancel)
        self.layout.addLayout(btn_layout)

    def update_remove_buttons(self):
        for i, widget in enumerate(self.line_widgets):
            is_last_empty = (i == len(self.line_widgets) - 1) and widget.is_empty()
            is_first_and_only = widget.is_first and len(self.line_widgets) == 1
            
            if is_first_and_only or is_last_empty:
                widget.btn_remove.hide()
                if not getattr(widget, "_has_spacer", False):
                    widget._top_row.addItem(widget.spacer_item)
                    widget._has_spacer = True
            else:
                widget.btn_remove.show()
                if getattr(widget, "_has_spacer", False):
                    for j in range(widget._top_row.count()):
                        it = widget._top_row.itemAt(j)
                        if it and it.spacerItem() is widget.spacer_item:
                            widget._top_row.takeAt(j)
                            break
                    widget._has_spacer = False
        try:
            self.scroll_content.updateGeometry()
        except Exception:
            pass

    def is_last_empty_widget(self, widget):
        return (self.line_widgets and
                widget is self.line_widgets[-1] and
                widget.is_empty())

    def add_line(self, text=""):
        widget = URLLineWidget(parent_dialog=self, initial_url=text)
        widget.line_edited.connect(lambda w=widget: self.on_line_edited(w))
        widget.delete_requested.connect(self.delete_line)
        widget.paste_multi.connect(self.handle_paste_multi)
        self.scroll_layout.insertWidget(self.scroll_layout.count() - 1, widget)
        self.line_widgets.append(widget)
        if widget.get_url():
            self.fetch_meta_for_widget(widget)
        if hasattr(self, "first_line"):
            self.update_remove_buttons()
        return widget

    def handle_paste_multi(self, widget, url_list):
        insert_at = 0
        for u in url_list:
            new_w = URLLineWidget(parent_dialog=self, initial_url=u)
            new_w.line_edited.connect(lambda w=new_w: self.on_line_edited(w))
            new_w.delete_requested.connect(self.delete_line)
            new_w.paste_multi.connect(self.handle_paste_multi)
            self.scroll_layout.insertWidget(insert_at, new_w)
            self.line_widgets.insert(insert_at, new_w)
            self.fetch_meta_for_widget(new_w)
            insert_at += 1
        self.ensure_trailing_empty()
        self.update_remove_buttons()

    def delete_line(self, widget):
        if widget is getattr(self, "first_line", None):
            if len(self.line_widgets) == 1:
                widget.line_edit.clear()
                return
            else:
                try:
                    self.first_line.line_edit.textChanged.disconnect(self.first_line._on_first_line_changed)
                except (TypeError, RuntimeError):
                    pass
                new_first = self.line_widgets[1]
                new_first.is_first = True
                self.first_line = new_first
                self.first_line.line_edit.textChanged.connect(self.first_line._on_first_line_changed)
        if self.is_last_empty_widget(widget):
            return
        if widget not in self.line_widgets:
            return
        try:
            cb = self._mgr_callbacks.pop(widget, None) if hasattr(self, "_mgr_callbacks") else None
        except Exception:
            cb = None

        if cb:
            try:
                mgr_for_cb, on_fetched, on_error, on_status, _ = cb
                try: mgr_for_cb.resolutions_fetched.disconnect(on_fetched)
                except Exception: pass
                try: mgr_for_cb.error.disconnect(on_error)
                except Exception: pass
                try: mgr_for_cb.status_update.disconnect(on_status)
                except Exception: pass
            except Exception:
                pass
        url = widget.get_url()
        if url:
            mgr = None
            if cb and isinstance(cb, tuple) and cb[0]:
                mgr = cb[0]
            else:
                parent = getattr(self, '_owner', None) or self.parent()
                mgr = getattr(parent, 'metadata_manager', None) or getattr(self, '_local_metadata_manager', None)

            if mgr and hasattr(mgr, 'cancel'):
                try:
                    mgr.cancel(url)
                except Exception:
                    pass
        if hasattr(self, "_loading_timers") and widget in self._loading_timers:
            try:
                self._loading_timers[widget].stop()
            except Exception:
                pass
            self._loading_timers.pop(widget, None)
        t = self.info_threads.get(widget)
        if t and t.isRunning():
            try:
                t.terminate()
            except Exception:
                pass
        self.info_threads.pop(widget, None)
        try: widget.line_edited.disconnect()
        except Exception: pass
        try: widget.delete_requested.disconnect()
        except Exception: pass
        try: widget.paste_multi.disconnect()
        except Exception: pass
        try:
            self.line_widgets.remove(widget)
            widget.setParent(None)
            widget.deleteLater()
        except (ValueError, RuntimeError):
            pass
        self.ensure_trailing_empty()
        self.update_remove_buttons()

    def ensure_trailing_empty(self):
        if not self.line_widgets or not self.line_widgets[-1].is_empty():
            self.add_line("")
        if hasattr(self, "first_line"):
            self.update_remove_buttons()

    def check_and_remove_empty_line_if_only_first(self):
        if len(self.line_widgets) == 2:
            last_widget = self.line_widgets[-1]
            if last_widget.is_empty() and last_widget is not self.first_line:
                try:
                    self.line_widgets.remove(last_widget)
                    last_widget.setParent(None)
                    last_widget.deleteLater()
                except Exception:
                    pass

    def fetch_meta_for_widget(self, widget):
        url = widget.get_url()
        if not url:
            return

        parent = getattr(self, '_owner', None) or self.parent()
        if parent and hasattr(parent, 'metadata_manager'):
            mgr = parent.metadata_manager
        else:
            if not hasattr(self, '_local_metadata_manager'):
                self._local_metadata_manager = MetadataManager()
            mgr = self._local_metadata_manager

        norm = url.strip()

        # při startu blokuj download button
        if parent and hasattr(parent, "download_btn"):
            parent.download_btn.setEnabled(False)
            try:
                parent.progress_bar.setFormat("Loading video info...")
            except Exception:
                pass

        if norm in mgr.cache:
            data = mgr.cache[norm]
            if data.get("is_playlist") and data.get("is_radio_playlist"):
                title = data.get("title", "Radio/Mix")
                track_count = len(data.get("urls", []))
                widget.set_meta(f"Title: {title} | Tracks: {track_count}")
            else:
                duration = data.get("duration", 0)
                mins, secs = int(duration // 60), int(duration % 60)
                resolutions = data.get("resolutions", [])
                best = resolutions[0] if resolutions else "N/A"
                widget.set_meta(
                    f"Title: {data.get('title','Unknown')} | Duration: {mins:02d}:{secs:02d} | Best: {best}"
                )
            # hotovo – odblokuj tlačítko
            if parent and hasattr(parent, "download_btn"):
                parent.download_btn.setEnabled(True)
                try:
                    parent.progress_bar.setFormat("Ready to download...")
                except Exception:
                    pass
            return

        spinner_frames = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]
        spinner_index = 0
        try:
            widget.set_meta(f"Loading info. {spinner_frames[spinner_index]}")
        except RuntimeError:
            pass
        timer = QTimer(self)

        def on_timeout():
            nonlocal spinner_index
            spinner_index = (spinner_index + 1) % len(spinner_frames)
            try:
                widget.set_meta(f"Loading info. {spinner_frames[spinner_index]}")
            except RuntimeError:
                pass

        timer.timeout.connect(on_timeout)
        timer.start(150)
        if not hasattr(self, '_loading_timers'):
            self._loading_timers = {}
        self._loading_timers[widget] = timer
        expected = norm

        def on_fetched(u, data):
            if u != expected or u in mgr._cancelled:
                return
            if widget not in self.line_widgets:
                try:
                    mgr.resolutions_fetched.disconnect(on_fetched)
                    mgr.error.disconnect(on_error)
                    mgr.status_update.disconnect(on_status)
                except Exception:
                    pass
                self._mgr_callbacks.pop(widget, None)
                return

            try:
                timer.stop()
            except Exception:
                pass
            self._loading_timers.pop(widget, None)

            # normální zpracování metadat
            title = data.get("title", "Unknown")
            duration = data.get("duration", 0)
            mins, secs = int(duration // 60), int(duration % 60)
            resolutions = data.get("resolutions", [])
            best = resolutions[0] if resolutions else "N/A"
            try:
                widget.set_meta(f"Title: {title} | Duration: {mins:02d}:{secs:02d} | Best: {best}")
            except RuntimeError:
                pass

            # odblokuj tlačítko
            if parent and hasattr(parent, "download_btn"):
                parent.download_btn.setEnabled(True)
                try:
                    parent.progress_bar.setFormat("Ready to download...")
                except Exception:
                    pass

            try:
                mgr.resolutions_fetched.disconnect(on_fetched)
                mgr.error.disconnect(on_error)
                mgr.status_update.disconnect(on_status)
            except Exception:
                pass
            self._mgr_callbacks.pop(widget, None)

        def on_error(u, msg):
            if u != expected or u in mgr._cancelled:
                return
            try:
                timer.stop()
            except Exception:
                pass
            self._loading_timers.pop(widget, None)
            try:
                widget.set_meta(f"Error: {msg}")
            except RuntimeError:
                pass
            # chyba → taky odblokuj tlačítko
            if parent and hasattr(parent, "download_btn"):
                parent.download_btn.setEnabled(True)
                try:
                    parent.progress_bar.setFormat("Error fetching info")
                except Exception:
                    pass
            try:
                mgr.resolutions_fetched.disconnect(on_fetched)
                mgr.error.disconnect(on_error)
                mgr.status_update.disconnect(on_status)
            except Exception:
                pass
            self._mgr_callbacks.pop(widget, None)

        def on_status(u, s):
            if u != expected or u in mgr._cancelled:
                return
            if widget not in self.line_widgets:
                return
            try:
                widget.set_meta(s)
            except RuntimeError:
                pass

        self._mgr_callbacks[widget] = (mgr, on_fetched, on_error, on_status, expected)
        mgr.resolutions_fetched.connect(on_fetched)
        mgr.error.connect(on_error)
        mgr.status_update.connect(on_status)
        mgr.request(expected)

    def on_line_edited(self, widget):
        if widget is getattr(self, "first_line", None):
            if widget.is_empty():
                self.check_and_remove_empty_line_if_only_first()
            else:
                self.fetch_meta_for_widget(widget)
                self.ensure_trailing_empty()
        else:
            if self.line_widgets and widget is self.line_widgets[-1] and not widget.is_empty():
                self.add_line()
            if not widget.is_empty():
                self.fetch_meta_for_widget(widget)
            else:
                widget.clear_meta()
        self.update_remove_buttons()

    def accept(self):
        urls = [w.get_url() for w in self.line_widgets if w.get_url()]
        self.closed.emit(urls)
        self._cleanup_threads()
        self.close()

    def reject(self):
        self.closed.emit([])
        self._cleanup_threads()
        self.close()

    def _cleanup_threads(self):
        for t in list(self.info_threads.values()):
            try:
                if t.isRunning(): t.quit()
            except Exception: pass
        self.info_threads.clear()

# ----------------------
# YouTubeDownloader (main window) - adjusted to use MultiURLDialog
# ----------------------

class YouTubeDownloader(QMainWindow):
    def __init__(self):
        super().__init__()
        bin_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'bin')
        self.yt_dlp_path = os.path.join(bin_dir, "yt-dlp.exe") if sys.platform == "win32" else "yt-dlp"
        self.ffmpeg_path = os.path.join(bin_dir, "ffmpeg.exe") if sys.platform == "win32" else "ffmpeg"
        # --- Konec opravy ---

        missing = check_dependencies()
        if missing:
            QMessageBox.critical(self, "Chybějící závislost", f"Soubor '{missing}' nebyl nalezen. Aplikace se ukončí.")
            sys.exit(1)

        self.setWindowTitle("YouTube Downloader Ultimate v1.0")
        self.setFixedSize(750, 530)
        self.default_resolutions = ["2160p", "1440p", "1080p", "720p", "480p", "360p", "240p"]
        self.compression_presets = ["Original (No Re-encoding)", "High Quality (Compressed)", "Medium Quality", "Low Quality"]
        self.mp3_bitrates = ["320", "256", "192", "128", "96"]
        self.video_info = {}
        self.download_thread, self.info_thread = None, None
        self.urls_to_download = []
        self.meta_load_times = []
        self.metadata_manager = MetadataManager()
        videos_path = Path.home() / "Videos"
        self.save_path = str((videos_path if videos_path.exists() else Path.home() / "Downloads") / "YTDownload")
        os.makedirs(self.save_path, exist_ok=True)
        self.center_window()
        self.init_ui()
        self.progress_bar.setFormat("Ready...") # po startu
        self.progress_bar.setValue(0)

    def center_window(self):
        screen_center = QApplication.primaryScreen().geometry().center()
        self.move(screen_center - self.frameGeometry().center())

    def init_ui(self):
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        self._last_single_url = ""
        main_layout = QVBoxLayout(central_widget)
        main_layout.setSpacing(15)
        main_layout.setContentsMargins(20, 20, 20, 0)
        title_label = QLabel(f"🎬 {self.windowTitle()}")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setStyleSheet("font-size: 22px; font-weight: bold; color: #2a82da; margin-bottom: 10px;")
        main_layout.addWidget(title_label)
        
        # URL Group
        url_group = QGroupBox("🎞 Video Source ")
        url_layout = QVBoxLayout(url_group)
        url_input_layout = QHBoxLayout()
        self.url_input = QLineEdit(placeholderText="Enter a YouTube URL and press Enter, or use buttons...")
        self.url_input.setClearButtonEnabled(True)
        self.url_input.returnPressed.connect(self.fetch_video_info)
        self.url_input.textChanged.connect(self.on_url_text_changed)

        self.btn_paste = QPushButton("Paste URL", clicked=self.paste_url)
        self.btn_multi_url = QPushButton("Multiple URLs", clicked=self.open_multi_url_dialog)

        url_input_layout.addWidget(self.url_input)
        url_input_layout.addWidget(self.btn_paste)
        url_input_layout.addWidget(self.btn_multi_url)
        url_layout.addLayout(url_input_layout)

        self.video_info_label = QLabel("")
        self.video_info_label.setStyleSheet("color: #aaa; font-style: italic; font-size: 11px;")
        self.video_info_label.setWordWrap(True)
        url_layout.addWidget(self.video_info_label)
        main_layout.addWidget(url_group)

        # Download Settings
        settings_group = QGroupBox("📝 Download Settings ")
        settings_group.setFixedHeight(190)
        settings_layout = QGridLayout(settings_group)

        # Nastavení menších okrajů a mezer
        settings_layout.setContentsMargins(0, 0, 8, 8)
        settings_layout.setVerticalSpacing(10)

        # --- První řádek ---
        settings_layout.addWidget(QLabel("    Format:"), 0, 0)
        self.format_combo = QComboBox()
        self.format_combo.addItems(["MP4 (video+audio)", "MP3"])
        self.format_combo.currentIndexChanged.connect(self.update_ui_visibility)
        settings_layout.addWidget(self.format_combo, 0, 1)

        # --- Druhý řádek (pro video) ---
        self.video_quality_label = QLabel("    Video Quality:")
        settings_layout.addWidget(self.video_quality_label, 1, 0)
        self.quality_combo = QComboBox()
        self.quality_combo.setStyleSheet("margin-top: 10px;")
        self.quality_combo.addItems(self.default_resolutions)
        self.quality_combo.setCurrentText("1080p")
        settings_layout.addWidget(self.quality_combo, 1, 1)

        # --- Druhý řádek (pro MP3, schovaný) ---
        self.mp3_bitrate_label = QLabel("   MP3 Bitrate (kbps):")
        settings_layout.addWidget(self.mp3_bitrate_label, 1, 0)
        self.mp3_bitrate_combo = QComboBox()
        self.mp3_bitrate_combo.addItems(self.mp3_bitrates)
        self.mp3_bitrate_combo.setCurrentText("320")
        settings_layout.addWidget(self.mp3_bitrate_combo, 1, 1)

        # --- Třetí řádek ---
        self.compression_label = QLabel("    Compression:")
        settings_layout.addWidget(self.compression_label, 2, 0)
        self.compression_combo = QComboBox()
        self.compression_combo.addItems(self.compression_presets)
        settings_layout.addWidget(self.compression_combo, 2, 1)
        main_layout.addWidget(settings_group)

        # Progress and Buttons
        self.progress_bar = QProgressBar(textVisible=True, format="Ready to download...")
        self.progress_bar.setFixedHeight(32)
        main_layout.addWidget(self.progress_bar)

        btn_layout = QHBoxLayout()
        self.folder_btn = QPushButton(f".../{os.path.basename(self.save_path)} 📁", clicked=self.select_folder)
        self.download_btn = QPushButton("Download ⬇️", clicked=self.start_or_cancel_download)
        btn_layout.addWidget(self.folder_btn)
        btn_layout.addWidget(self.download_btn)
        main_layout.addLayout(btn_layout)

        # GPU Info
        gpu_mode, gpu_encoder = check_gpu_support()
        mode_labels = {
            "qsv": "Intel QSV",
            "nvenc": "NVIDIA NVENC",
            "amf": "AMD AMF",
            "vaapi": "VAAPI",
            "videotoolbox": "VideoToolbox",
            "cpu": "CPU Only"
        }
        gpu_text = mode_labels.get(gpu_mode, "Unknown")
        if gpu_mode != "cpu":
            gpu_text += f" ({gpu_encoder})"

        gpu_info = QLabel(f"Encoding by: {gpu_text}")
        gpu_info.setStyleSheet("color: #aaa; font-size: 10px; padding-left: 8px;")
        gpu_info.setAlignment(Qt.AlignmentFlag.AlignLeft)
        main_layout.addWidget(gpu_info)

        self.update_ui_visibility()
        self.setStyleSheet(self.get_stylesheet())

    def get_stylesheet(self):
        return """
            QMainWindow, QWidget { background-color: #2d2d2d; }
            QGroupBox { font-weight: bold; color: #fff; border: 2px solid #555; border-radius: 12px; margin-top: 8px; padding-top: 10px; }
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; padding: 0 8px; background-color: #2d2d2d; }
            QLabel { color: #fff; font-size: 12px; font-weight: bold; }
            QLineEdit { background-color: #404040; border: 2px solid #555; border-radius: 12px; padding: 10px; color: #fff; font-size: 12px; }
            QLineEdit::clear-button { background-color: transparent; border: none; image: url(cross-icon.png); /* Fallback, styling is tricky */ }
            QComboBox { background-color: #404040; border: 2px solid #555; border-radius: 12px; padding: 10px; color: #fff; }
            QComboBox::drop-down { border: none; }
            QComboBox::down-arrow { image: url(down-arrow.png); /* Needs an icon */ }
            QComboBox QAbstractItemView { border: 2px solid #555; border-radius: 10px; background-color: #404040; selection-background-color: #2a82da; }
            QPushButton { background-color: #2a82da; border-radius: 12px; padding: 12px 16px; color: #fff; font-weight: bold; border: none; }
            QPushButton:hover { background-color: #3d95ed; }
            QPushButton:pressed { background-color: #1e6bb8; }
            QPushButton:disabled { background-color: #555; color: #999; }
            QProgressBar { border: 2px solid #555; border-radius: 10px; text-align: center; background-color: #404040; color: white; font-weight: bold; }
            QProgressBar::chunk { background-color: #2a82da; border-radius: 8px; margin: 1px; }
            
        """

    def on_url_text_changed(self, text):
        text = text.strip()
        old_url = getattr(self, "_last_single_url", "").strip()
        if not text:
            self.video_info_label.setText("")
            self.progress_bar.setFormat("Ready to download...")
            self.progress_bar.setValue(0)
            self.reset_to_default_qualities()
            if hasattr(self, "_loading_timer"):
                try:
                    self._loading_timer.stop()
                except Exception:
                    pass
                self._loading_timer = None
            if old_url:
                try:
                    self.metadata_manager.cancel(old_url)
                except Exception:
                    pass
        self._last_single_url = text

    def internal_login(self):
        try:
            # Takhle je to správně
            _SESSION_MANAGER.create_session_for_youtube(name='default', interactive=True, headless=False)
            QMessageBox.information(self, "Session uložena", "Interní session byla vytvořena a cookies uloženy. Pokud jsi se přihlásil, program je nyní použije.")
        except Exception as e:
            QMessageBox.warning(self, "Chyba", f"Nepodařilo se vytvořit interní session: {e}")

    def start_programmatic_login(self):
        email = self.email_input.text()
        password = self.password_input.text()

        if not email or not password:
            QMessageBox.warning(self, "Chyba", "Musíš zadat email i heslo!")
            return
        
        # Spustíme přihlašování v samostatném vlákně, aby nezamrzlo GUI
        thread = threading.Thread(target=self.run_login_logic, args=(email, password))
        thread.start()

    def run_login_logic(self, email, password):
        # Necháme okno viditelné, ať vidíme, co se děje.
        headless_mode = False 

        try:
            from playwright.sync_api import sync_playwright
            from playwright_stealth import stealth_sync
            import time # <- Ujisti se, že máš na začátku souboru import time

            with sync_playwright() as p:
                browser = p.chromium.launch(headless=headless_mode)
                page = browser.new_page()
                stealth_sync(page)

                print("Naviguji na Google login...")
                page.goto("https://accounts.google.com/signin")

                # --- KROK 1: Vyplnění emailu ---
                print(f"Hledám pole pro email...")
                email_locator = page.locator('input[type="email"]')
                
                email_locator.wait_for(timeout=15000)
                email_locator.click() 
                email_locator.fill(email)
                print(f"Vyplněn email: {email}")
                
                page.locator("button:has-text('Další')").click()
                print("Kliknuto na 'Další' po zadání emailu.")
                
                # --- KLÍČOVÁ PAUZA ---
                # Dáme Googlu 2-3 sekundy na to, aby se vzpamatoval a načetl stránku s heslem
                print("Čekám 3 sekundy, než se načte stránka s heslem...")
                time.sleep(3)
                # ---------------------

                # --- KROK 2: Vyplnění hesla ---
                print("Hledám viditelné pole pro heslo...")
                password_locator = page.locator('input[type="password"]:not([aria-hidden="true"])')
                
                password_locator.wait_for(timeout=20000)
                password_locator.click()
                password_locator.fill(password)
                print("Vyplněno heslo...")

                page.locator("button:has-text('Další')").click()
                print("Kliknuto na 'Další' po zadání hesla.")

                # --- KROK 3: Ověření úspěchu ---
                print("Čekám na potvrzení přihlášení...")
                page.wait_for_url("**/myaccount.google.com/**", timeout=45000)
                
                print("ÚSPĚCH! Přihlášení se zdařilo.")

                cookies = page.context.cookies()
                _SESSION_MANAGER.save_cookies_json(cookies, "default")
                print("Cookies byly úspěšně uloženy.")
                
                browser.close()

        except Exception as e:
            print("--------------------------------------------------")
            print("BĚHEM PROGRAMOVÉHO PŘIHLÁŠENÍ NASTALA ZÁSADNÍ CHYBA:")
            print(f"Typ chyby: {type(e).__name__}")
            print(f"Zpráva: {e}")
            print("Zkontroluj přihlašovací údaje. Pokud ani teď přihlášení nefunguje, je téměř jisté, že Google pro tvůj účet vyžaduje dvoufaktorové ověření (2FA) nebo CAPTCHA, které tento skript neumí automaticky obejít.")
            print("--------------------------------------------------")





    def update_ui_visibility(self):
        is_mp4 = self.format_combo.currentText() == 'MP4 (video+audio)'
        self.video_quality_label.setVisible(is_mp4)
        self.quality_combo.setVisible(is_mp4)
        self.compression_label.setVisible(is_mp4)
        self.compression_combo.setVisible(is_mp4)
        self.mp3_bitrate_label.setVisible(not is_mp4)
        self.mp3_bitrate_combo.setVisible(not is_mp4)

    def fetch_video_info(self):
        url = self.url_input.text().strip()
        if url and not self.urls_to_download and re.match(r'^https?://(www\.)?(youtube\.com|youtu\.be)/\S+', url):
            self.progress_bar.setFormat("Wait...")
            self.progress_bar.setValue(0)
            self.download_btn.setEnabled(False)
            self.video_info_label.setStyleSheet(
                "QLabel { color: #1b84c4; margin-left: 2px; padding: 2px 0 2px 0;}"
            )
            mgr = self.metadata_manager
            norm = url.strip()
            if norm in mgr.cache:
                data = mgr.cache[norm]
                self.update_quality_combo(data)
                self.download_btn.setEnabled(True)
                self.progress_bar.setFormat("Ready to download...")
                return

            # spinner
            spinner_frames = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]
            spinner_index = 0
            self.video_info_label.setText(f"Loading video info... {spinner_frames[spinner_index]}")

            self._loading_timer = QTimer(self)

            def on_tick():
                nonlocal spinner_index
                spinner_index = (spinner_index + 1) % len(spinner_frames)
                self.video_info_label.setText(f"Loading video info... {spinner_frames[spinner_index]}")
            self._loading_timer.timeout.connect(on_tick)
            self._loading_timer.start(150)

            def on_res(u, data):
                if u != norm or u in mgr._cancelled:
                    return
                try:
                    self._loading_timer.stop()
                except Exception:
                    pass
                if "entries" in data or data.get("is_playlist"):
                    reply = QMessageBox.question(
                        self,
                        "Playlist detected",
                        "This link is a playlist.\nDo you want to split it into individual videos?",
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                        QMessageBox.StandardButton.Yes
                    )
                    if reply == QMessageBox.StandardButton.Yes:
                        entries = data.get("entries", [])
                        urls = [e.get("webpage_url") for e in entries if e.get("webpage_url")]
                        if urls:
                            self.urls_to_download = urls
                            self.open_multi_url_dialog()
                        return
                    else:
                        self.update_quality_combo(data)
                        self.download_btn.setEnabled(True)
                        self.progress_bar.setFormat("Ready to download...")
                else:
                    self.update_quality_combo(data)
                    self.download_btn.setEnabled(True)
                    self.progress_bar.setFormat("Ready to download...")

                try:
                    mgr.resolutions_fetched.disconnect(on_res)
                except Exception:
                    pass
                try:
                    mgr.error.disconnect(on_err)
                except Exception:
                    pass
                try:
                    mgr.status_update.disconnect(on_stat)
                except Exception:
                    pass

            def on_err(u, msg):
                if u != norm or u in mgr._cancelled:
                    return
                try:
                    self._loading_timer.stop()
                except Exception:
                    pass
                self.progress_bar.setFormat("Error fetching info")
                QMessageBox.warning(self, "Metadata Error", f"Could not load video info.\n\nReason: {msg}")
                self.download_btn.setEnabled(True)
                try:
                    mgr.resolutions_fetched.disconnect(on_res)
                except Exception:
                    pass
                try:
                    mgr.error.disconnect(on_err)
                except Exception:
                    pass
                try:
                    mgr.status_update.disconnect(on_stat)
                except Exception:
                    pass

            def on_stat(u, s):
                if u != norm or u in mgr._cancelled:
                    return
                self.progress_bar.setFormat(s)

            import time
            self._meta_start_time = time.time()
            mgr.resolutions_fetched.connect(on_res)
            mgr.error.connect(on_err)
            mgr.status_update.connect(on_stat)
            mgr.request(norm)

    def update_quality_combo(self, data):
        self.quality_combo.clear()
        self.quality_combo.addItems(data["resolutions"])
        self.video_info = data
        duration = data.get("duration", 0)
        self.video_info_label.setText(f" Video: {data.get('title', 'N/A')} | Duration: {int(duration/60):02d}:{int(duration%60):02d} | Best: {data['resolutions'][0] if data['resolutions'] else 'N/A'}")
        if "1080p" in data["resolutions"]:
            self.quality_combo.setCurrentText("1080p")
        self.download_btn.setEnabled(True)
        self.progress_bar.setFormat("Ready to download...")

    def info_fetch_error(self, message):
        self.progress_bar.setFormat("Error fetching info")
        QMessageBox.warning(self, "Metadata Error", f"Could not load video info.\n\nReason: {message}")
        self.download_btn.setEnabled(True)
    DEFAULT_BROWSER = None
    _DETECTED_BROWSER = None

    def detect_default_browser():
        import sys
        if sys.platform != "win32":
            return None
        try:
            import winreg
            path = r"Software\Microsoft\Windows\Shell\Associations\UrlAssociations\https\UserChoice"
            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, path) as key:
                progid, _ = winreg.QueryValueEx(key, "ProgId")
                progid = progid.lower()
                if "chrome" in progid:
                    return "chrome"
                if "firefox" in progid:
                    return "firefox"
                if "edge" in progid or "microsoft" in progid:
                    return "edge"
                if "brave" in progid:
                    return "brave"
        except Exception:
            pass
        return None
    _DETECTED_BROWSER = detect_default_browser()
    DEFAULT_BROWSER = _DETECTED_BROWSER or "firefox"



    def paste_url(self):
        clip = QApplication.clipboard().text().strip()
        if re.match(r'^https?://(www\.)?(youtube\.com|youtu\.be)/\S+', clip):
            canon = canonicalize_youtube_url(clip)
            self.url_input.setText(canon)
            self._last_single_url = canon
            self.fetch_video_info()
        else:
            QMessageBox.information(self, "Invalid URL", "Clipboard does not contain a valid YouTube URL.")

    def open_multi_url_dialog(self):
        self.reset_to_default_qualities()
        main_url = self.url_input.text().strip()
        urls = []
        if self.urls_to_download:
            urls = [canonicalize_youtube_url(u) for u in self.urls_to_download]
        elif main_url:
            urls = [canonicalize_youtube_url(main_url)]
        self.multi_url_dialog = MultiURLDialog(self, urls=urls)
        if urls and self.multi_url_dialog.line_widgets:
            first_widget = self.multi_url_dialog.line_widgets[0]
            if first_widget.get_url():
                mgr = getattr(self, 'metadata_manager', None)
                if mgr:
                    norm = canonicalize_youtube_url(first_widget.get_url())
                    if norm in mgr.cache:
                        data = mgr.cache[norm]
                        title = data.get("title", "Unknown")
                        duration = data.get("duration", 0)
                        mins, secs = int(duration // 60), int(duration % 60)
                        resolutions = data.get("resolutions", [])
                        best = resolutions[0] if resolutions else "N/A"
                        first_widget.set_meta(f"Title: {title} | Duration: {mins:02d}:{secs:02d} | Best: {best}")
                    else:
                        self.multi_url_dialog.fetch_meta_for_widget(first_widget)
                else:
                    self.multi_url_dialog.fetch_meta_for_widget(first_widget)
        self.multi_url_dialog.closed.connect(self.handle_multi_url_close)
        self.multi_url_dialog.show()

    def handle_multi_url_close(self, urls):
        if urls:
            self.urls_to_download = urls
            self.url_input.setText(f"{len(urls)} videos in queue...")
            self.url_input.setReadOnly(True)
            self.video_info_label.setText(f"Multiple videos selected: {len(urls)} URLs in queue")
        else:
            pass
        self.multi_url_dialog = None

    def select_folder(self):
        folder = QFileDialog.getExistingDirectory(self, "Select Save Folder", str(Path(self.save_path).parent))
        if folder:
            self.save_path = os.path.join(folder, "YTDownload")
            os.makedirs(self.save_path, exist_ok=True)
            self.folder_btn.setText(f"📁 .../{os.path.basename(self.save_path)}")

    def start_or_cancel_download(self):
        if self.download_thread and self.download_thread.isRunning():
            self._cancelled_by_user = True
            self.download_thread.cancel()
            self.progress_bar.setFormat("Cancelled...")
            self.progress_bar.setStyleSheet(""" QProgressBar { color: #e74c3c;} QProgressBar::chunk { background-color: #2a82da; border-radius: 8px; margin: 1px;}""")
            self.progress_bar.setValue(0)
            self.download_btn.setEnabled(True)
            def reset_ui():
                self._cancelled_by_user = False
                self.progress_bar.setFormat("Ready...")
                self.progress_bar.setStyleSheet(""" QProgressBar { color: white;} QProgressBar::chunk { background-color: #2a82da; border-radius: 8px; margin: 1px;}""")
                self.progress_bar.setValue(0)
                self.set_ui_for_download(False)

            QTimer.singleShot(1500, reset_ui)
        else:
            self.start_download()

    def start_download(self):
        urls = self.urls_to_download or ([self.url_input.text().strip()] if self.url_input.text().strip() else [])
        urls = [u.strip() for u in urls if u.strip()]

        if not urls:
            QMessageBox.warning(self, "No URLs", "Please enter at least one YouTube URL.")
            return
        self.set_ui_for_download(True)
        self.progress_bar.setValue(0)
        params = {
            "urls": urls,
            "save_path": self.save_path,
            "format_opt": self.format_combo.currentText(),
            "video_quality": self.quality_combo.currentText(),
            "compression_mode": self.compression_combo.currentText(),
            "mp3_bitrate": int(self.mp3_bitrate_combo.currentText()),
            "duration_s": self.video_info.get("duration", 0),
            "title": self.video_info.get("title") if len(urls) == 1 else None,
            "yt_dlp_path": self.yt_dlp_path,
            "ffmpeg_path": self.ffmpeg_path
        }
        self.download_thread = DownloadThread(**params)
        self.download_thread.progress.connect(self.update_progress)
        self.download_thread.finished.connect(self.download_finished)
        self.download_thread.error.connect(self.download_error)
        self.download_thread.start()

    def update_progress(self, percent, status_text):
        self.progress_bar.setValue(percent)
        self.progress_bar.setFormat(status_text)

    def download_finished(self, is_last):
        if is_last:
            self.progress_bar.setFormat("Download complete!")
            self.progress_bar.setValue(100)
            reply = QMessageBox.information(
                self,
                "Complete!",
                f"All videos downloaded successfully.\nSaved to: {self.save_path}",
                QMessageBox.StandardButton.Ok | QMessageBox.StandardButton.Open
            )
            if reply == QMessageBox.StandardButton.Open:
                try:
                    if sys.platform == "win32":
                        os.startfile(self.save_path)
                    elif sys.platform == "darwin":
                        subprocess.Popen(["open", self.save_path])
                    else:
                        subprocess.Popen(["xdg-open", self.save_path])
                except Exception:
                    pass
            self.set_ui_for_download(False)

    def download_error(self, msg):
        if msg == "Cancelled":
            self.progress_bar.setFormat("Cancelled.")
            self.progress_bar.setValue(0)

            def reset_bar():
                self.progress_bar.setFormat("Ready to download...")
                self.progress_bar.setValue(0)
            QTimer.singleShot(2000, reset_bar)
            self.progress_bar.setStyleSheet(""" QProgressBar { color: white; } QProgressBar::chunk { background-color: #2a82da; border-radius: 8px; margin: 1px;}""")
            self.set_ui_for_download(False)
        else:
            QMessageBox.critical(self, "Download Error", msg)
            self.set_ui_for_download(False)

    def set_ui_for_download(self, is_downloading):
        if is_downloading:
            self.download_btn.setText("Cancel ❌")
            self.download_btn.setEnabled(True)
            self.download_btn.setStyleSheet(""" QPushButton { background-color: #e74c3c; border-radius: 12px; padding: 12px 16px; color: #fff; font-weight: bold; border: none;} QPushButton:hover { background-color: #ff5c5c; } QPushButton:pressed { background-color: #c0392b;border:none;}""")
        else:
            self.download_btn.setText("Download ⬇️")
            self.download_btn.setEnabled(True)
            self.download_btn.setStyleSheet(""" QPushButton {background-color: #2a82da; border-radius: 12px; padding: 12px 16px; color: #fff; font-weight: bold; border: none;} QPushButton:hover { background-color: #3d95ed; } QPushButton:pressed { background-color: #1e6bb8; }""")
        for widget in [self.url_input, self.btn_paste, self.btn_multi_url,
                    self.format_combo, self.quality_combo, self.mp3_bitrate_combo,
                    self.compression_combo, self.folder_btn]:
            try:
                widget.setEnabled(not is_downloading)
            except Exception:
                pass
        if is_downloading:
            self.progress_bar.setValue(0)
            self.progress_bar.setFormat("Downloading...")
        else:
            if not getattr(self, "_cancelled_by_user", False):
                self.progress_bar.setFormat("Ready...")
                self.progress_bar.setValue(0)

    def reset_ui(self):
        self.set_ui_for_download(False)
        self.url_input.setReadOnly(False)
        self.progress_bar.setFormat("Prepare to download...")
        self.progress_bar.setValue(0)
        self.reset_to_default_qualities()

    def reset_to_default_qualities(self):
        self.quality_combo.clear()
        self.quality_combo.addItems(self.default_resolutions)
        self.quality_combo.setCurrentText("1080p")

if __name__ == "__main__":

    app = QApplication(sys.argv)
    downloader = YouTubeDownloader()
    downloader.show()
    sys.exit(app.exec())

